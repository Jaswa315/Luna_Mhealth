
# Python script to convert a json of dart metrics to a csv file
# Allows for plotting of certain metrics via matplotlib
# Usage: 
#      python .\generate_code_metric_charts.py <PATH TO METRICS JSON FILE> --outputDir <DIR FOR OUTPUTTED FILES> --savePlot --showPlot 
# The only required parameter is the first positional parameter which is the metrics json file
# The output dir folder is the location of the saved csv and saved graphs. By default, it is ".\"
# --savePlot is a switch to save the matplotlib plots to the outputdir
# --showPlot is a switch to display the matplotlib plots to the user


# Coverted from "Steps to Create Code Metrics"
# https://docs.google.com/document/u/1/d/1Xnp5d1hEQVTVEm0PRYzAWG159poKSeGYt2HuY5YrQu0/edit?usp=drive_web&ouid=115409931295648588135
# That doc has the dart version of these steps to parse out code metrics

#dart command in terminal to generate metrics
# run this command in the flutter/dart app of interest (ie luna_authoring_system)
# dart pub global run dart_code_metrics:metrics lib --reporter=json --disable-sunset-warning --json-path=metrics.json



import json
import matplotlib.pyplot as plt
import pandas as pd
from collections import defaultdict
import numpy as np
import argparse


#region plot constants
HORIZONTAL_JITTER = 0.15
FIG_SIZE = (12, 6)
BOX_PLOT_ALPHA = 0.3
SCATTER_PLOT_JITTER = .7
SCATTER_PLOT_POINT_SIZE = 20
METHOD_GRAPH_METRICS = ["cyclomatic-complexity", "loc", "nesting", "maintainability"]
CLASS_GRAPH_METRICS = ["cyclomatic-complexity", "loc", "nesting", "maintainability"]
#endregion


# Function to parse
# Expects a fully qaulified path to a json file of the metrics generated by the dart metris tool.

def parse_metrics_json(path_to_json):
    function_metrics = defaultdict(dict)
    class_metrics = defaultdict(dict)

    with open(path_to_json) as f:
        metric_json = json.load(f)
        metric_records = metric_json['records']


    df_columns = [
        "class",
        "function",
        "cyclomatic-complexity",
        "loc",
        "nesting",
        "maintainability",
        "halstead-volume",
        "number-of-parameters",
        "class-number-of-methods",
        "class-weight-of-class"]
    df = pd.DataFrame(columns=df_columns)

    for record in metric_records:

        # Classes
        classes = record.get('classes', {})
        for class_name, class_data in classes.items():
            class_metrics[class_name] = {
                m['metricsId']: m['value'] for m in class_data.get('metrics', [])
            }

        # Functions
        functions = record.get('functions', {})
        for func_name, func_data in functions.items():
            metrics = {m['metricsId']: m['value'] for m in func_data.get('metrics', [])}
            class_name = func_name.split('.')[0] if '.' in func_name else "<global>"
            function_metrics[class_name][func_name] = metrics
            df.loc[len(df)] = [
                class_name,
                func_name,
                metrics.get("cyclomatic-complexity"),
                metrics.get("lines-of-code"),
                metrics.get("maximum-nesting-level"),
                metrics.get("maintainability-index"),
                metrics.get("halstead-volume"),
                metrics.get("number-of-parameters"),
                class_metrics.get(class_name).get("number-of-methods") if class_name!="<global>" else None,
                class_metrics.get(class_name).get("weight-of-class") if class_name!="<global>" else None
            ]

    # Average the metrics on class
    df_classes = df.groupby('class').agg({
        'cyclomatic-complexity': 'mean',
        'nesting': 'mean',
        'maintainability': 'mean',
        'loc': 'sum',
        'class-number-of-methods': 'mean',
        'class-weight-of-class': 'mean'
    }).reset_index()

    return df,df_classes

# Takes a given pandas dataframe and creates a box and scatter plot.
# Metrics is an array of columns from the dataframe of which to graph
# Title is the title of the plots. 
def plot_dot_and_box(df, title, metrics, show_plot, save_plot, output_dir="./"):
    fig, ax = plt.subplots(figsize=FIG_SIZE)
    box_data = [df[m].values for m in metrics]
    # Draw boxplots
    bp = ax.boxplot(
        box_data,
        positions=range(len(metrics)),
        patch_artist=True,
        showfliers=False)
    
    # Make boxes transluscent
    for patch in bp['boxes']:
        patch.set_alpha(BOX_PLOT_ALPHA)

    # Draw dot plot and add horizontal jitter for readability
    for i, metric in enumerate(metrics):
        values = df[metric].values
        jitter = (np.random.rand(len(values)) - 0.5) * HORIZONTAL_JITTER
        ax.scatter(np.full_like(values, i) + jitter, values, alpha=SCATTER_PLOT_JITTER, color='black', s=SCATTER_PLOT_POINT_SIZE)

    ax.set_xticks(range(len(metrics)))
    ax.set_xticklabels(metrics, rotation=45)
    ax.set_title(title)
    ax.set_ylabel('Value')
    plt.tight_layout() # Tight layout ensures whitespace around plots is not abnormally large/small
    if save_plot:
        plt.savefig(f"{output_dir}/{title}.png")
    if show_plot:
        plt.show()

# Function to parse arguements for this script
def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("metricsFile", help="Path to metrics json file")
    parser.add_argument("--outputDir", default="./", type=str, help="Directory to save csv and plots. Defaults to cwd")
    parser.add_argument("--savePlot", action="store_true", help="Save plot to the current working directory")
    parser.add_argument("--showPlot", action="store_true", help="Display the plots after running the file")
    args = parser.parse_args()
    return args.metricsFile,args.outputDir,args.savePlot,args.showPlot

if __name__ == "__main__":

    metrics_file,output_dir,save_plot,show_plot = parse_arguments()
    # df_classes is average of df_methods per class
    df_methods,df_class = parse_metrics_json(metrics_file)

    # Save the methods df to a csv
    df_methods.to_csv(f'{output_dir}/metrics.csv', index=False)

    if (show_plot or save_plot):
        plot_dot_and_box(
            df_methods,
            "Method Quality Metrics",
            METHOD_GRAPH_METRICS,
            show_plot,
            save_plot,
            output_dir = output_dir
        )
        plot_dot_and_box(
            df_class,
            "Class Aggregated Quality Metrics",
            CLASS_GRAPH_METRICS,
            show_plot,
            save_plot,
            output_dir = output_dir
        )
